<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ClasspathDescriptor.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">duplicate-finder-maven-plugin Maven Mojo</a> &gt; <a href="index.source.html" class="el_package">org.basepom.mojo.duplicatefinder.classpath</a> &gt; <span class="el_source">ClasspathDescriptor.java</span></div><h1>ClasspathDescriptor.java</h1><pre class="source lang-java linenums">/*
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.basepom.mojo.duplicatefinder.classpath;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

import javax.lang.model.SourceVersion;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.MoreObjects;
import com.google.common.base.Predicate;
import com.google.common.base.Predicates;
import com.google.common.base.Splitter;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableMultimap;
import com.google.common.collect.Multimap;
import com.google.common.collect.MultimapBuilder;
import com.google.common.io.Closer;
import com.google.common.io.Files;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import org.apache.maven.artifact.Artifact;
import org.apache.maven.artifact.versioning.InvalidVersionSpecificationException;
import org.apache.maven.plugin.MojoExecutionException;
import org.apache.maven.project.MavenProject;
import org.basepom.mojo.duplicatefinder.ConflictType;
import org.basepom.mojo.duplicatefinder.PluginLog;
import org.basepom.mojo.duplicatefinder.artifact.MavenCoordinates;

import static java.lang.String.format;

import static com.google.common.base.Preconditions.checkNotNull;
import static com.google.common.base.Preconditions.checkState;

@SuppressFBWarnings(&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;)
public class ClasspathDescriptor {

<span class="fc" id="L63">    private static final PluginLog LOG = new PluginLog(ClasspathDescriptor.class);</span>

<span class="fc" id="L65">    private static final MatchPatternPredicate DEFAULT_IGNORED_RESOURCES_PREDICATE = new MatchPatternPredicate(Arrays.asList(</span>
            // Standard jar folders
            &quot;^META-INF/.*&quot;,
            &quot;^OSGI-INF/.*&quot;,
            // directory name that shows up all the time
            &quot;^licenses/.*&quot;,
            // file names that show up all the time
            &quot;.*license(\\.txt)?$&quot;,
            &quot;.*notice(\\.txt)?$&quot;,
            &quot;.*readme(\\.txt)?$&quot;,
            &quot;.*changelog(\\.txt)?$&quot;,
            &quot;.*third-party(\\.txt)?$&quot;,
            // HTML stuff from javadocs.
            &quot;.*package\\.html$&quot;,
            &quot;.*overview\\.html$&quot;));

    @VisibleForTesting
<span class="fc" id="L82">    static final MatchPatternPredicate DEFAULT_IGNORED_CLASS_PREDICATE = new MatchPatternPredicate(Arrays.asList(</span>

            &quot;^(.*\\.)?.*\\$.*$&quot;,      // matches inner classes in any package
            &quot;^(.*\\.)?package-info$&quot;, // matches package-info in any package
            &quot;^(.*\\.)?module-info$&quot;   // matches module-info in any package
    ));

<span class="fc" id="L89">    private static final MatchPatternPredicate DEFAULT_IGNORED_LOCAL_DIRECTORIES = new MatchPatternPredicate(Arrays.asList(</span>
            &quot;^.git$&quot;,
            &quot;^.svn$&quot;,
            &quot;^.hg$&quot;,
            &quot;^.bzr$&quot;));

    /**
     * This is a global, static cache which can be reused through multiple runs of the plugin in the same VM,
     * e.g. for a multi-module build.
     */
<span class="fc" id="L99">    private static final ConcurrentMap&lt;File, ClasspathCacheElement&gt; CACHED_BY_FILE = new ConcurrentHashMap&lt;&gt;();</span>

<span class="fc" id="L101">    private final Multimap&lt;String, File&gt; classesWithElements = MultimapBuilder.treeKeys().hashSetValues().build();</span>
<span class="fc" id="L102">    private final Multimap&lt;String, File&gt; resourcesWithElements = MultimapBuilder.treeKeys().hashSetValues().build();</span>

    private final Predicate&lt;String&gt; resourcesPredicate;
    private final Predicate&lt;String&gt; classPredicate;

    private final ImmutableList&lt;Pattern&gt; ignoredResourcePatterns;
    private final ImmutableList&lt;Pattern&gt; ignoredClassPatterns;

    public static ClasspathDescriptor createClasspathDescriptor(final MavenProject project,
            final Multimap&lt;File, Artifact&gt; fileToArtifactMap,
            final Collection&lt;String&gt; ignoredResourcePatterns,
            final Collection&lt;String&gt; ignoredClassPatterns,
            final Collection&lt;MavenCoordinates&gt; ignoredDependencies,
            final boolean useDefaultResourceIgnoreList,
            final boolean useDefaultClassIgnoreList,
            final Set&lt;File&gt; bootClasspath,
            final File[] projectFolders) throws MojoExecutionException, InvalidVersionSpecificationException {
<span class="fc" id="L119">        checkNotNull(project, &quot;project is null&quot;);</span>
<span class="fc" id="L120">        checkNotNull(fileToArtifactMap, &quot;fileToArtifactMap is null&quot;);</span>
<span class="fc" id="L121">        checkNotNull(ignoredResourcePatterns, &quot;ignoredResourcePatterns is null&quot;);</span>
<span class="fc" id="L122">        checkNotNull(ignoredClassPatterns, &quot;ignoredClassPatterns is null&quot;);</span>
<span class="fc" id="L123">        checkNotNull(ignoredDependencies, &quot;ignoredDependencies is null&quot;);</span>
<span class="fc" id="L124">        checkNotNull(projectFolders, &quot;projectFolders is null&quot;);</span>

<span class="fc" id="L126">        final ClasspathDescriptor classpathDescriptor = new ClasspathDescriptor(useDefaultResourceIgnoreList, ignoredResourcePatterns,</span>
                useDefaultClassIgnoreList, ignoredClassPatterns);

<span class="fc" id="L129">        File file = null;</span>

        try {
<span class="pc bpc" id="L132" title="1 of 2 branches missed.">            for (File bootClasspathElement : bootClasspath) {</span>
<span class="nc" id="L133">                file = bootClasspathElement;</span>
<span class="nc bnc" id="L134" title="All 2 branches missed.">                if (file.exists()) {</span>
<span class="nc" id="L135">                    LOG.debug(&quot;Adding '%s' as a boot classpath element&quot;, file);</span>
<span class="nc" id="L136">                    classpathDescriptor.addClasspathElement(file);</span>
                } else {
<span class="nc" id="L138">                    LOG.debug(&quot;Ignoring '%s', does not exist.&quot;, file);</span>
                }
<span class="nc" id="L140">            }</span>
<span class="nc" id="L141">        } catch (final IOException ex) {</span>
<span class="nc" id="L142">            throw new MojoExecutionException(format(&quot;Error trying to access file '%s' from boot classpath&quot;, file), ex);</span>
<span class="fc" id="L143">        }</span>

<span class="fc" id="L145">        final MatchArtifactPredicate matchArtifactPredicate = new MatchArtifactPredicate(ignoredDependencies);</span>

<span class="fc" id="L147">        Artifact artifact = null;</span>

        try {
            // any entry is either a jar in the repo or a folder in the target folder of a referenced
            // project. Add the elements that are not ignored by the ignoredDependencies predicate to
            // the classpath descriptor.
<span class="fc bfc" id="L153" title="All 2 branches covered.">            for (final Map.Entry&lt;File, Artifact&gt; entry : fileToArtifactMap.entries()) {</span>
<span class="fc" id="L154">                artifact = entry.getValue();</span>
<span class="fc" id="L155">                file = entry.getKey();</span>

<span class="pc bpc" id="L157" title="1 of 2 branches missed.">                if (file.exists()) {</span>
                    // Add to the classpath if the artifact predicate does not apply (then it is not in the ignoredDependencies list).
<span class="fc bfc" id="L159" title="All 2 branches covered.">                    if (!matchArtifactPredicate.apply(artifact)) {</span>
<span class="fc" id="L160">                        classpathDescriptor.addClasspathElement(file);</span>
                    }
                } else {
                    // e.g. when running the goal explicitly on a cleaned multi-module project, referenced
                    // projects will try to use the output folders of a referenced project but these do not
                    // exist. Obviously, in this case the plugin might return incorrect results (unfortunately
                    // false negatives, but there is not much it can do here (besides fail the build here with a
                    // cryptic error message. Maybe add a flag?).
<span class="nc" id="L168">                    LOG.debug(&quot;Classpath element '%s' does not exist.&quot;, file.getAbsolutePath());</span>
                }
<span class="fc" id="L170">            }</span>
<span class="nc" id="L171">        } catch (final IOException ex) {</span>
<span class="nc" id="L172">            throw new MojoExecutionException(format(&quot;Error trying to access file '%s' for artifact '%s'&quot;, file, artifact), ex);</span>
<span class="fc" id="L173">        }</span>

        try {
            // Add project folders unconditionally.
<span class="fc bfc" id="L177" title="All 2 branches covered.">            for (final File projectFile : projectFolders) {</span>
<span class="fc" id="L178">                file = projectFile;</span>
<span class="fc bfc" id="L179" title="All 2 branches covered.">                if (projectFile.exists()) {</span>
<span class="fc" id="L180">                    classpathDescriptor.addClasspathElement(file);</span>
                } else {
                    // See above. This may happen in the project has been cleaned before running the goal directly.
<span class="fc" id="L183">                    LOG.debug(&quot;Project folder '%s' does not exist.&quot;, file.getAbsolutePath());</span>
                }
            }
<span class="nc" id="L186">        } catch (final IOException ex) {</span>
<span class="nc" id="L187">            throw new MojoExecutionException(format(&quot;Error trying to access project folder '%s'&quot;, file), ex);</span>
<span class="fc" id="L188">        }</span>

<span class="fc" id="L190">        return classpathDescriptor;</span>
    }

    private ClasspathDescriptor(final boolean useDefaultResourceIgnoreList,
            final Collection&lt;String&gt; ignoredResourcePatterns,
            final boolean useDefaultClassIgnoreList,
            final Collection&lt;String&gt; ignoredClassPatterns)
<span class="fc" id="L197">            throws MojoExecutionException {</span>
<span class="fc" id="L198">        final ImmutableList.Builder&lt;Pattern&gt; ignoredResourcePatternsBuilder = ImmutableList.builder();</span>

        // build resource predicate...
<span class="fc" id="L201">        Predicate&lt;String&gt; resourcesPredicate = Predicates.alwaysFalse();</span>

        // predicate matching the default ignores
<span class="fc bfc" id="L204" title="All 2 branches covered.">        if (useDefaultResourceIgnoreList) {</span>
<span class="fc" id="L205">            resourcesPredicate = Predicates.or(resourcesPredicate, DEFAULT_IGNORED_RESOURCES_PREDICATE);</span>
<span class="fc" id="L206">            ignoredResourcePatternsBuilder.addAll(DEFAULT_IGNORED_RESOURCES_PREDICATE.getPatterns());</span>
        }

<span class="fc bfc" id="L209" title="All 2 branches covered.">        if (!ignoredResourcePatterns.isEmpty()) {</span>
            try {
                // predicate matching the user ignores
<span class="fc" id="L212">                MatchPatternPredicate ignoredResourcesPredicate = new MatchPatternPredicate(ignoredResourcePatterns);</span>
<span class="fc" id="L213">                resourcesPredicate = Predicates.or(resourcesPredicate, ignoredResourcesPredicate);</span>
<span class="fc" id="L214">                ignoredResourcePatternsBuilder.addAll(ignoredResourcesPredicate.getPatterns());</span>
<span class="nc" id="L215">            } catch (final PatternSyntaxException pse) {</span>
<span class="nc" id="L216">                throw new MojoExecutionException(&quot;Error compiling resourceIgnore pattern: &quot; + pse.getMessage());</span>
<span class="fc" id="L217">            }</span>
        }

<span class="fc" id="L220">        this.resourcesPredicate = resourcesPredicate;</span>
<span class="fc" id="L221">        this.ignoredResourcePatterns = ignoredResourcePatternsBuilder.build();</span>

<span class="fc" id="L223">        final ImmutableList.Builder&lt;Pattern&gt; ignoredClassPatternsBuilder = ImmutableList.builder();</span>

        // build class predicate.
<span class="fc" id="L226">        Predicate&lt;String&gt; classPredicate = Predicates.alwaysFalse();</span>

        // predicate matching the default ignores
<span class="pc bpc" id="L229" title="1 of 2 branches missed.">        if (useDefaultClassIgnoreList) {</span>
<span class="fc" id="L230">            classPredicate = Predicates.or(classPredicate, DEFAULT_IGNORED_CLASS_PREDICATE);</span>
<span class="fc" id="L231">            ignoredClassPatternsBuilder.addAll(DEFAULT_IGNORED_CLASS_PREDICATE.getPatterns());</span>
        }

<span class="fc bfc" id="L234" title="All 2 branches covered.">        if (!ignoredClassPatterns.isEmpty()) {</span>
            try {
                // predicate matching the user ignores
<span class="fc" id="L237">                MatchPatternPredicate ignoredPackagePredicate = new MatchPatternPredicate(ignoredClassPatterns);</span>
<span class="fc" id="L238">                classPredicate = Predicates.or(classPredicate, ignoredPackagePredicate);</span>
<span class="fc" id="L239">                ignoredClassPatternsBuilder.addAll(ignoredPackagePredicate.getPatterns());</span>
<span class="nc" id="L240">            } catch (final PatternSyntaxException pse) {</span>
<span class="nc" id="L241">                throw new MojoExecutionException(&quot;Error compiling classIgnore pattern: &quot; + pse.getMessage());</span>
<span class="fc" id="L242">            }</span>
        }

<span class="fc" id="L245">        this.classPredicate = classPredicate;</span>
<span class="fc" id="L246">        this.ignoredClassPatterns = ignoredClassPatternsBuilder.build();</span>
<span class="fc" id="L247">    }</span>

    public ImmutableMap&lt;String, Collection&lt;File&gt;&gt; getClasspathElementLocations(final ConflictType type) {
<span class="fc" id="L250">        checkNotNull(type, &quot;type is null&quot;);</span>
<span class="pc bpc" id="L251" title="1 of 3 branches missed.">        switch (type) {</span>
            case CLASS:
<span class="fc" id="L253">                return ImmutableMultimap.copyOf(classesWithElements).asMap();</span>
            case RESOURCE:
<span class="fc" id="L255">                return ImmutableMultimap.copyOf(resourcesWithElements).asMap();</span>
            default:
<span class="nc" id="L257">                throw new IllegalStateException(&quot;Type '&quot; + type + &quot;' unknown!&quot;);</span>
        }
    }

    public ImmutableList&lt;Pattern&gt; getIgnoredResourcePatterns() {
<span class="fc" id="L262">        return ignoredResourcePatterns;</span>
    }

    public ImmutableList&lt;Pattern&gt; getIgnoredClassPatterns() {
<span class="fc" id="L266">        return ignoredClassPatterns;</span>
    }

    public ImmutableList&lt;Pattern&gt; getIgnoredDirectoryPatterns() {
<span class="fc" id="L270">        return DEFAULT_IGNORED_LOCAL_DIRECTORIES.getPatterns();</span>
    }


    private void addClasspathElement(final File element) throws IOException {
<span class="fc" id="L275">        checkState(element.exists(), &quot;Path '%s' does not exist!&quot;, element.getAbsolutePath());</span>

<span class="fc" id="L277">        ClasspathCacheElement cached = CACHED_BY_FILE.get(element);</span>

<span class="fc bfc" id="L279" title="All 2 branches covered.">        if (cached == null) {</span>
<span class="fc" id="L280">            final ClasspathCacheElement.Builder cacheBuilder = ClasspathCacheElement.builder(element);</span>
<span class="fc bfc" id="L281" title="All 2 branches covered.">            if (element.isDirectory()) {</span>
<span class="fc" id="L282">                addDirectory(cacheBuilder, element, new PackageNameHolder());</span>
            } else {
<span class="fc" id="L284">                addArchive(cacheBuilder, element);</span>
            }
<span class="fc" id="L286">            final ClasspathCacheElement newCached = cacheBuilder.build();</span>
<span class="fc" id="L287">            final ClasspathCacheElement oldCached = CACHED_BY_FILE.putIfAbsent(element, newCached);</span>
<span class="fc" id="L288">            cached = MoreObjects.firstNonNull(oldCached, newCached);</span>
<span class="fc" id="L289">        } else {</span>
<span class="fc" id="L290">            LOG.debug(&quot;Cache hit for '%s'&quot;, element.getAbsolutePath());</span>
        }

<span class="fc" id="L293">        cached.putResources(resourcesWithElements, resourcesPredicate);</span>
<span class="fc" id="L294">        cached.putClasses(classesWithElements, classPredicate);</span>

<span class="fc" id="L296">    }</span>

    private void addDirectory(final ClasspathCacheElement.Builder cacheBuilder, final File workDir, final PackageNameHolder packageName) {
<span class="fc" id="L299">        final File[] files = workDir.listFiles();</span>

<span class="pc bpc" id="L301" title="1 of 2 branches missed.">        if (files != null) {</span>
<span class="fc bfc" id="L302" title="All 2 branches covered.">            for (final File file : Arrays.asList(files)) {</span>
<span class="fc bfc" id="L303" title="All 2 branches covered.">                if (file.isDirectory()) {</span>
<span class="pc bpc" id="L304" title="1 of 2 branches missed.">                    if (DEFAULT_IGNORED_LOCAL_DIRECTORIES.apply(file.getName())) {</span>
<span class="nc" id="L305">                        LOG.debug(&quot;Ignoring local directory '%s'&quot;, file.getAbsolutePath());</span>
                    } else {
<span class="fc" id="L307">                        addDirectory(cacheBuilder, file, packageName.getChildPackage(file.getName()));</span>
                    }

<span class="pc bpc" id="L310" title="1 of 2 branches missed.">                } else if (file.isFile()) {</span>
<span class="fc bfc" id="L311" title="All 2 branches covered.">                    if (&quot;class&quot;.equals(Files.getFileExtension(file.getName()))) {</span>
<span class="fc" id="L312">                        final String className = packageName.getQualifiedName(Files.getNameWithoutExtension(file.getName()));</span>
<span class="fc" id="L313">                        cacheBuilder.addClass(className);</span>
<span class="fc" id="L314">                    } else {</span>
<span class="fc" id="L315">                        final String resourcePath = packageName.getQualifiedPath(file.getName());</span>
<span class="fc" id="L316">                        cacheBuilder.addResource(resourcePath);</span>
<span class="fc" id="L317">                    }</span>
                } else {
<span class="nc" id="L319">                    LOG.warn(&quot;Ignoring unknown file type for '%s'&quot;, file.getAbsolutePath());</span>
                }
<span class="fc" id="L321">            }</span>
        }
<span class="fc" id="L323">    }</span>

    private void addArchive(final ClasspathCacheElement.Builder cacheBuilder, final File element) throws IOException {
<span class="fc" id="L326">        final Closer closer = Closer.create();</span>

        try {
<span class="fc" id="L329">            final InputStream input = closer.register(element.toURI().toURL().openStream());</span>
<span class="fc" id="L330">            final ZipInputStream zipInput = closer.register(new ZipInputStream(input));</span>

            ZipEntry entry;

<span class="fc bfc" id="L334" title="All 2 branches covered.">            while ((entry = zipInput.getNextEntry()) != null) {</span>
<span class="fc bfc" id="L335" title="All 2 branches covered.">                if (!entry.isDirectory()) {</span>
<span class="fc" id="L336">                    final String name = entry.getName();</span>
<span class="fc" id="L337">                    Optional&lt;List&lt;String&gt;&gt; validatedElements = validateClassName(name);</span>
<span class="fc bfc" id="L338" title="All 2 branches covered.">                    if (validatedElements.isPresent()) {</span>
<span class="fc" id="L339">                        List&lt;String&gt; nameElements = validatedElements.get();</span>
<span class="fc" id="L340">                        final PackageNameHolder packageName = new PackageNameHolder(nameElements.subList(0, nameElements.size() - 1));</span>
<span class="fc" id="L341">                        final String className = packageName.getQualifiedName(Files.getNameWithoutExtension(name));</span>
<span class="fc" id="L342">                        cacheBuilder.addClass(className);</span>
<span class="fc" id="L343">                    } else {</span>
<span class="fc" id="L344">                        final String resourcePath = name.replace('\\', File.separatorChar);</span>
<span class="fc" id="L345">                        cacheBuilder.addResource(resourcePath);</span>
                    }
<span class="fc" id="L347">                }</span>
            }
        } finally {
<span class="fc" id="L350">            closer.close();</span>
        }
<span class="fc" id="L352">    }</span>

    @VisibleForTesting
    static Optional&lt;List&lt;String&gt;&gt; validateClassName(String fullClassPath) {
<span class="pc bpc" id="L356" title="1 of 2 branches missed.">        if (fullClassPath == null) {</span>
<span class="nc" id="L357">            return Optional.empty();</span>
        }

        // ZIP/Jars always use &quot;/&quot; as separators
<span class="fc" id="L361">        final List&lt;String&gt; nameElements = ImmutableList.copyOf(Splitter.on(&quot;/&quot;).splitToList(fullClassPath));</span>
<span class="pc bpc" id="L362" title="1 of 2 branches missed.">        if (nameElements.isEmpty()) {</span>
<span class="nc" id="L363">            LOG.warn(&quot;ZIP entry '%s' split into empty list!&quot;, fullClassPath);</span>
<span class="nc" id="L364">            return Optional.empty();</span>
        }
<span class="fc" id="L366">        String classFileName = nameElements.get(nameElements.size() - 1);</span>

<span class="fc bfc" id="L368" title="All 2 branches covered.">        if (!&quot;class&quot;.equals(Files.getFileExtension(classFileName))) {</span>
<span class="fc" id="L369">            LOG.debug(&quot;Ignoring %s, %s is not a class file&quot;, fullClassPath, classFileName);</span>
<span class="fc" id="L370">            return Optional.empty();</span>
        }
<span class="fc bfc" id="L372" title="All 2 branches covered.">        for (int i = 0; i &lt; nameElements.size() - 1; i++) {</span>
<span class="fc bfc" id="L373" title="All 2 branches covered.">            if (!SourceVersion.isIdentifier(nameElements.get(i))) {</span>
<span class="fc" id="L374">                LOG.debug(&quot;Ignoring %s, %s is not a valid package element&quot;, fullClassPath, nameElements.get(i));</span>
<span class="fc" id="L375">                return Optional.empty();</span>
            }
        }

<span class="fc" id="L379">        String className = Files.getNameWithoutExtension(classFileName);</span>
<span class="fc bfc" id="L380" title="All 2 branches covered.">        if (!(SourceVersion.isIdentifier(className)</span>
<span class="fc bfc" id="L381" title="All 2 branches covered.">                || &quot;module-info&quot;.equals(className)</span>
<span class="pc bpc" id="L382" title="1 of 2 branches missed.">                || &quot;package-info&quot;.equals(className))) {</span>
<span class="nc" id="L383">            LOG.debug(&quot;Ignoring %s, %s is not a valid class identifier&quot;, fullClassPath, className);</span>
<span class="nc" id="L384">            return Optional.empty();</span>
        }

<span class="fc" id="L387">        return Optional.of(nameElements);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>