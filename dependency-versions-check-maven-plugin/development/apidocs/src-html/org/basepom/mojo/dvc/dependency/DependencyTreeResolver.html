<!DOCTYPE HTML>
<html lang>
<head>
<!-- Generated by javadoc (21) -->
<title>Source code</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="source: package: org.basepom.mojo.dvc.dependency, class: DependencyTreeResolver">
<meta name="generator" content="javadoc/SourceToHTMLConverter">
<link rel="stylesheet" type="text/css" href="../../../../../../stylesheet.css" title="Style">
</head>
<body class="source-page">
<main role="main">
<div class="source-container">
<pre><span class="source-line-no">001</span><span id="line-1">/*</span>
<span class="source-line-no">002</span><span id="line-2"> * Licensed under the Apache License, Version 2.0 (the "License");</span>
<span class="source-line-no">003</span><span id="line-3"> * you may not use this file except in compliance with the License.</span>
<span class="source-line-no">004</span><span id="line-4"> * You may obtain a copy of the License at</span>
<span class="source-line-no">005</span><span id="line-5"> *</span>
<span class="source-line-no">006</span><span id="line-6"> * http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="source-line-no">007</span><span id="line-7"> *</span>
<span class="source-line-no">008</span><span id="line-8"> * Unless required by applicable law or agreed to in writing, software</span>
<span class="source-line-no">009</span><span id="line-9"> * distributed under the License is distributed on an "AS IS" BASIS,</span>
<span class="source-line-no">010</span><span id="line-10"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="source-line-no">011</span><span id="line-11"> * See the License for the specific language governing permissions and</span>
<span class="source-line-no">012</span><span id="line-12"> * limitations under the License.</span>
<span class="source-line-no">013</span><span id="line-13"> */</span>
<span class="source-line-no">014</span><span id="line-14"></span>
<span class="source-line-no">015</span><span id="line-15">package org.basepom.mojo.dvc.dependency;</span>
<span class="source-line-no">016</span><span id="line-16"></span>
<span class="source-line-no">017</span><span id="line-17">import static com.google.common.base.Preconditions.checkNotNull;</span>
<span class="source-line-no">018</span><span id="line-18">import static com.google.common.base.Preconditions.checkState;</span>
<span class="source-line-no">019</span><span id="line-19">import static com.google.common.collect.ImmutableList.toImmutableList;</span>
<span class="source-line-no">020</span><span id="line-20">import static com.google.common.collect.ImmutableSet.toImmutableSet;</span>
<span class="source-line-no">021</span><span id="line-21">import static java.lang.String.format;</span>
<span class="source-line-no">022</span><span id="line-22">import static org.basepom.mojo.dvc.dependency.DependencyMapBuilder.convertToPomArtifact;</span>
<span class="source-line-no">023</span><span id="line-23"></span>
<span class="source-line-no">024</span><span id="line-24">import org.basepom.mojo.dvc.CheckExclusionsFilter;</span>
<span class="source-line-no">025</span><span id="line-25">import org.basepom.mojo.dvc.Context;</span>
<span class="source-line-no">026</span><span id="line-26">import org.basepom.mojo.dvc.PluginLog;</span>
<span class="source-line-no">027</span><span id="line-27">import org.basepom.mojo.dvc.QualifiedName;</span>
<span class="source-line-no">028</span><span id="line-28">import org.basepom.mojo.dvc.ScopeLimitingFilter;</span>
<span class="source-line-no">029</span><span id="line-29">import org.basepom.mojo.dvc.strategy.Strategy;</span>
<span class="source-line-no">030</span><span id="line-30">import org.basepom.mojo.dvc.version.VersionResolution;</span>
<span class="source-line-no">031</span><span id="line-31">import org.basepom.mojo.dvc.version.VersionResolutionCollection;</span>
<span class="source-line-no">032</span><span id="line-32"></span>
<span class="source-line-no">033</span><span id="line-33">import java.time.Duration;</span>
<span class="source-line-no">034</span><span id="line-34">import java.util.Collection;</span>
<span class="source-line-no">035</span><span id="line-35">import java.util.Set;</span>
<span class="source-line-no">036</span><span id="line-36">import java.util.concurrent.Callable;</span>
<span class="source-line-no">037</span><span id="line-37">import java.util.concurrent.ExecutionException;</span>
<span class="source-line-no">038</span><span id="line-38">import java.util.concurrent.Executors;</span>
<span class="source-line-no">039</span><span id="line-39">import java.util.concurrent.locks.Lock;</span>
<span class="source-line-no">040</span><span id="line-40">import java.util.concurrent.locks.ReentrantLock;</span>
<span class="source-line-no">041</span><span id="line-41"></span>
<span class="source-line-no">042</span><span id="line-42">import com.google.common.base.Joiner;</span>
<span class="source-line-no">043</span><span id="line-43">import com.google.common.collect.ImmutableList;</span>
<span class="source-line-no">044</span><span id="line-44">import com.google.common.collect.ImmutableSet;</span>
<span class="source-line-no">045</span><span id="line-45">import com.google.common.collect.ImmutableSetMultimap;</span>
<span class="source-line-no">046</span><span id="line-46">import com.google.common.util.concurrent.ListenableFuture;</span>
<span class="source-line-no">047</span><span id="line-47">import com.google.common.util.concurrent.ListeningExecutorService;</span>
<span class="source-line-no">048</span><span id="line-48">import com.google.common.util.concurrent.MoreExecutors;</span>
<span class="source-line-no">049</span><span id="line-49">import com.google.common.util.concurrent.ThreadFactoryBuilder;</span>
<span class="source-line-no">050</span><span id="line-50">import org.apache.maven.RepositoryUtils;</span>
<span class="source-line-no">051</span><span id="line-51">import org.apache.maven.artifact.resolver.AbstractArtifactResolutionException;</span>
<span class="source-line-no">052</span><span id="line-52">import org.apache.maven.artifact.versioning.ComparableVersion;</span>
<span class="source-line-no">053</span><span id="line-53">import org.apache.maven.artifact.versioning.OverConstrainedVersionException;</span>
<span class="source-line-no">054</span><span id="line-54">import org.apache.maven.plugin.MojoExecutionException;</span>
<span class="source-line-no">055</span><span id="line-55">import org.apache.maven.project.DependencyResolutionException;</span>
<span class="source-line-no">056</span><span id="line-56">import org.apache.maven.project.MavenProject;</span>
<span class="source-line-no">057</span><span id="line-57">import org.apache.maven.project.ProjectBuildingException;</span>
<span class="source-line-no">058</span><span id="line-58">import org.eclipse.aether.RepositorySystem;</span>
<span class="source-line-no">059</span><span id="line-59">import org.eclipse.aether.artifact.Artifact;</span>
<span class="source-line-no">060</span><span id="line-60">import org.eclipse.aether.artifact.ArtifactTypeRegistry;</span>
<span class="source-line-no">061</span><span id="line-61">import org.eclipse.aether.graph.Dependency;</span>
<span class="source-line-no">062</span><span id="line-62">import org.eclipse.aether.graph.DependencyFilter;</span>
<span class="source-line-no">063</span><span id="line-63">import org.eclipse.aether.graph.DependencyNode;</span>
<span class="source-line-no">064</span><span id="line-64">import org.eclipse.aether.resolution.VersionRangeRequest;</span>
<span class="source-line-no">065</span><span id="line-65">import org.eclipse.aether.resolution.VersionRangeResolutionException;</span>
<span class="source-line-no">066</span><span id="line-66">import org.eclipse.aether.resolution.VersionRangeResult;</span>
<span class="source-line-no">067</span><span id="line-67">import org.eclipse.aether.util.filter.AndDependencyFilter;</span>
<span class="source-line-no">068</span><span id="line-68"></span>
<span class="source-line-no">069</span><span id="line-69">public final class DependencyTreeResolver</span>
<span class="source-line-no">070</span><span id="line-70">        implements AutoCloseable {</span>
<span class="source-line-no">071</span><span id="line-71"></span>
<span class="source-line-no">072</span><span id="line-72">    private static final PluginLog LOG = new PluginLog(DependencyTreeResolver.class);</span>
<span class="source-line-no">073</span><span id="line-73"></span>
<span class="source-line-no">074</span><span id="line-74">    private static final int DEPENDENCY_RESOLUTION_NUM_THREADS = Runtime.getRuntime().availableProcessors() * 5;</span>
<span class="source-line-no">075</span><span id="line-75"></span>
<span class="source-line-no">076</span><span id="line-76">    private final Lock collectorLock = new ReentrantLock();</span>
<span class="source-line-no">077</span><span id="line-77"></span>
<span class="source-line-no">078</span><span id="line-78">    private final Context context;</span>
<span class="source-line-no">079</span><span id="line-79">    private final DependencyMap rootDependencyMap;</span>
<span class="source-line-no">080</span><span id="line-80"></span>
<span class="source-line-no">081</span><span id="line-81">    private final ListeningExecutorService executorService = MoreExecutors.listeningDecorator(Executors.newFixedThreadPool(DEPENDENCY_RESOLUTION_NUM_THREADS,</span>
<span class="source-line-no">082</span><span id="line-82">            new ThreadFactoryBuilder().setNameFormat("dependency-version-check-worker-%s").setDaemon(true).build()));</span>
<span class="source-line-no">083</span><span id="line-83"></span>
<span class="source-line-no">084</span><span id="line-84">    public DependencyTreeResolver(final Context context, final DependencyMap rootDependencyMap) {</span>
<span class="source-line-no">085</span><span id="line-85">        this.context = checkNotNull(context, "context is null");</span>
<span class="source-line-no">086</span><span id="line-86">        this.rootDependencyMap = checkNotNull(rootDependencyMap, "rootDependencyMap is null");</span>
<span class="source-line-no">087</span><span id="line-87">    }</span>
<span class="source-line-no">088</span><span id="line-88"></span>
<span class="source-line-no">089</span><span id="line-89">    @Override</span>
<span class="source-line-no">090</span><span id="line-90">    public void close() {</span>
<span class="source-line-no">091</span><span id="line-91">        MoreExecutors.shutdownAndAwaitTermination(executorService, Duration.ofSeconds(2));</span>
<span class="source-line-no">092</span><span id="line-92">    }</span>
<span class="source-line-no">093</span><span id="line-93"></span>
<span class="source-line-no">094</span><span id="line-94">    /**</span>
<span class="source-line-no">095</span><span id="line-95">     * Creates a map of all dependency version resolutions used in this project in a given scope. The result is a map from names to a list of version numbers</span>
<span class="source-line-no">096</span><span id="line-96">     * used in the project, based on the element requesting the version.</span>
<span class="source-line-no">097</span><span id="line-97">     * &lt;p&gt;</span>
<span class="source-line-no">098</span><span id="line-98">     * If the special scope "null" is used, a superset of all scopes is used (this is used by the check mojo).</span>
<span class="source-line-no">099</span><span id="line-99">     *</span>
<span class="source-line-no">100</span><span id="line-100">     * @param project     The maven project to resolve all dependencies for.</span>
<span class="source-line-no">101</span><span id="line-101">     * @param scopeFilter Limits the scopes to resolve.</span>
<span class="source-line-no">102</span><span id="line-102">     * @return Map from qualified names to possible version resolutions.</span>
<span class="source-line-no">103</span><span id="line-103">     * @throws MojoExecutionException Parallel dependency resolution failed.</span>
<span class="source-line-no">104</span><span id="line-104">     */</span>
<span class="source-line-no">105</span><span id="line-105">    public ImmutableSetMultimap&lt;QualifiedName, VersionResolutionCollection&gt; computeResolutionMap(final MavenProject project,</span>
<span class="source-line-no">106</span><span id="line-106">            final ScopeLimitingFilter scopeFilter)</span>
<span class="source-line-no">107</span><span id="line-107">            throws MojoExecutionException {</span>
<span class="source-line-no">108</span><span id="line-108">        checkNotNull(project, "project is null");</span>
<span class="source-line-no">109</span><span id="line-109">        checkNotNull(scopeFilter, "scope is null");</span>
<span class="source-line-no">110</span><span id="line-110"></span>
<span class="source-line-no">111</span><span id="line-111">        final ImmutableSetMultimap.Builder&lt;QualifiedName, VersionResolution&gt; collector = ImmutableSetMultimap.builder();</span>
<span class="source-line-no">112</span><span id="line-112">        final ImmutableList.Builder&lt;ListenableFuture&lt;?&gt;&gt; futureBuilder = ImmutableList.builder();</span>
<span class="source-line-no">113</span><span id="line-113"></span>
<span class="source-line-no">114</span><span id="line-114">        boolean useParallelDependencyResolution = context.useFastResolution();</span>
<span class="source-line-no">115</span><span id="line-115">        // Map from dependency name --&gt; list of resolutions found on the tree</span>
<span class="source-line-no">116</span><span id="line-116">        LOG.debug("Using parallel dependency resolution: %s", useParallelDependencyResolution);</span>
<span class="source-line-no">117</span><span id="line-117"></span>
<span class="source-line-no">118</span><span id="line-118">        final ImmutableList&lt;Dependency&gt; dependencies;</span>
<span class="source-line-no">119</span><span id="line-119">        if (context.useDeepScan()) {</span>
<span class="source-line-no">120</span><span id="line-120">            LOG.debug("Running deep scan");</span>
<span class="source-line-no">121</span><span id="line-121">            dependencies = ImmutableList.copyOf(</span>
<span class="source-line-no">122</span><span id="line-122">                    rootDependencyMap.getAllDependencies().values().stream().map(DependencyNode::getDependency).collect(toImmutableList()));</span>
<span class="source-line-no">123</span><span id="line-123">        } else {</span>
<span class="source-line-no">124</span><span id="line-124">            final ArtifactTypeRegistry stereotypes = context.getRepositorySystemSession().getArtifactTypeRegistry();</span>
<span class="source-line-no">125</span><span id="line-125"></span>
<span class="source-line-no">126</span><span id="line-126">            dependencies = ImmutableList.copyOf(</span>
<span class="source-line-no">127</span><span id="line-127">                    project.getDependencies().stream().map(d -&gt; RepositoryUtils.toDependency(d, stereotypes)).collect(toImmutableList()));</span>
<span class="source-line-no">128</span><span id="line-128">        }</span>
<span class="source-line-no">129</span><span id="line-129"></span>
<span class="source-line-no">130</span><span id="line-130">        final ImmutableSet.Builder&lt;Throwable&gt; throwableBuilder = ImmutableSet.builder();</span>
<span class="source-line-no">131</span><span id="line-131"></span>
<span class="source-line-no">132</span><span id="line-132">        if (useParallelDependencyResolution) {</span>
<span class="source-line-no">133</span><span id="line-133">            for (final Dependency dependency : dependencies) {</span>
<span class="source-line-no">134</span><span id="line-134">                futureBuilder.add(executorService.submit((Callable&lt;Void&gt;) () -&gt; {</span>
<span class="source-line-no">135</span><span id="line-135">                    resolveProjectDependency(dependency, scopeFilter, collector);</span>
<span class="source-line-no">136</span><span id="line-136">                    return null;</span>
<span class="source-line-no">137</span><span id="line-137">                }));</span>
<span class="source-line-no">138</span><span id="line-138">            }</span>
<span class="source-line-no">139</span><span id="line-139"></span>
<span class="source-line-no">140</span><span id="line-140">            final ImmutableList&lt;ListenableFuture&lt;?&gt;&gt; futures = futureBuilder.build();</span>
<span class="source-line-no">141</span><span id="line-141"></span>
<span class="source-line-no">142</span><span id="line-142">            for (final ListenableFuture&lt;?&gt; future : futures) {</span>
<span class="source-line-no">143</span><span id="line-143">                try {</span>
<span class="source-line-no">144</span><span id="line-144">                    future.get();</span>
<span class="source-line-no">145</span><span id="line-145">                } catch (InterruptedException e) {</span>
<span class="source-line-no">146</span><span id="line-146">                    Thread.currentThread().interrupt();</span>
<span class="source-line-no">147</span><span id="line-147">                } catch (ExecutionException e) {</span>
<span class="source-line-no">148</span><span id="line-148">                    throwableBuilder.add(e.getCause());</span>
<span class="source-line-no">149</span><span id="line-149">                }</span>
<span class="source-line-no">150</span><span id="line-150">            }</span>
<span class="source-line-no">151</span><span id="line-151">        } else {</span>
<span class="source-line-no">152</span><span id="line-152">            for (final Dependency dependency : dependencies) {</span>
<span class="source-line-no">153</span><span id="line-153">                try {</span>
<span class="source-line-no">154</span><span id="line-154">                    resolveProjectDependency(dependency, scopeFilter, collector);</span>
<span class="source-line-no">155</span><span id="line-155">                } catch (Exception e) {</span>
<span class="source-line-no">156</span><span id="line-156">                    throwableBuilder.add(e);</span>
<span class="source-line-no">157</span><span id="line-157">                }</span>
<span class="source-line-no">158</span><span id="line-158">            }</span>
<span class="source-line-no">159</span><span id="line-159">        }</span>
<span class="source-line-no">160</span><span id="line-160"></span>
<span class="source-line-no">161</span><span id="line-161">        final Set&lt;Throwable&gt; throwables = throwableBuilder.build();</span>
<span class="source-line-no">162</span><span id="line-162">        if (!throwables.isEmpty()) {</span>
<span class="source-line-no">163</span><span id="line-163">            throw processResolveProjectDependencyException(throwableBuilder.build());</span>
<span class="source-line-no">164</span><span id="line-164">        }</span>
<span class="source-line-no">165</span><span id="line-165"></span>
<span class="source-line-no">166</span><span id="line-166">        return VersionResolutionCollection.toResolutionMap(collector.build());</span>
<span class="source-line-no">167</span><span id="line-167">    }</span>
<span class="source-line-no">168</span><span id="line-168"></span>
<span class="source-line-no">169</span><span id="line-169">    private static MojoExecutionException processResolveProjectDependencyException(Set&lt;Throwable&gt; throwables) {</span>
<span class="source-line-no">170</span><span id="line-170">        ImmutableSet.Builder&lt;String&gt; failedDependenciesBuilder = ImmutableSet.builder();</span>
<span class="source-line-no">171</span><span id="line-171">        ImmutableSet.Builder&lt;String&gt; messageBuilder = ImmutableSet.builder();</span>
<span class="source-line-no">172</span><span id="line-172">        for (Throwable t : throwables) {</span>
<span class="source-line-no">173</span><span id="line-173">            if (t instanceof DependencyResolutionException) {</span>
<span class="source-line-no">174</span><span id="line-174">                ((DependencyResolutionException) t).getResult().getUnresolvedDependencies()</span>
<span class="source-line-no">175</span><span id="line-175">                        .forEach(d -&gt; failedDependenciesBuilder.add(printDependency(d)));</span>
<span class="source-line-no">176</span><span id="line-176">            } else {</span>
<span class="source-line-no">177</span><span id="line-177">                messageBuilder.add(t.getMessage());</span>
<span class="source-line-no">178</span><span id="line-178">            }</span>
<span class="source-line-no">179</span><span id="line-179">        }</span>
<span class="source-line-no">180</span><span id="line-180"></span>
<span class="source-line-no">181</span><span id="line-181">        String message = Joiner.on("    \n").join(messageBuilder.build());</span>
<span class="source-line-no">182</span><span id="line-182">        Set&lt;String&gt; failedDependencies = failedDependenciesBuilder.build();</span>
<span class="source-line-no">183</span><span id="line-183">        if (!failedDependencies.isEmpty()) {</span>
<span class="source-line-no">184</span><span id="line-184">            if (!message.isEmpty()) {</span>
<span class="source-line-no">185</span><span id="line-185">                message += "\n";</span>
<span class="source-line-no">186</span><span id="line-186">            }</span>
<span class="source-line-no">187</span><span id="line-187">            message += "Could not resolve dependencies: [" + Joiner.on(", ").join(failedDependencies) + "]";</span>
<span class="source-line-no">188</span><span id="line-188">        }</span>
<span class="source-line-no">189</span><span id="line-189">        return new MojoExecutionException(message);</span>
<span class="source-line-no">190</span><span id="line-190">    }</span>
<span class="source-line-no">191</span><span id="line-191"></span>
<span class="source-line-no">192</span><span id="line-192">    private static String printDependency(Dependency d) {</span>
<span class="source-line-no">193</span><span id="line-193">        return d.getArtifact() + " [" + d.getScope() + (d.isOptional() ? ", optional" : "") + "]";</span>
<span class="source-line-no">194</span><span id="line-194">    }</span>
<span class="source-line-no">195</span><span id="line-195"></span>
<span class="source-line-no">196</span><span id="line-196">    /**</span>
<span class="source-line-no">197</span><span id="line-197">     * Called for any direct project dependency. Factored out from {@link #computeResolutionMap} to allow parallel evaluation of dependencies to speed up the</span>
<span class="source-line-no">198</span><span id="line-198">     * process.</span>
<span class="source-line-no">199</span><span id="line-199">     */</span>
<span class="source-line-no">200</span><span id="line-200">    private void resolveProjectDependency(final Dependency dependency,</span>
<span class="source-line-no">201</span><span id="line-201">            final ScopeLimitingFilter visibleScopes,</span>
<span class="source-line-no">202</span><span id="line-202">            final ImmutableSetMultimap.Builder&lt;QualifiedName, VersionResolution&gt; collector)</span>
<span class="source-line-no">203</span><span id="line-203">            throws MojoExecutionException, DependencyResolutionException, AbstractArtifactResolutionException, VersionRangeResolutionException {</span>
<span class="source-line-no">204</span><span id="line-204">        final QualifiedName dependencyName = QualifiedName.fromDependency(dependency);</span>
<span class="source-line-no">205</span><span id="line-205"></span>
<span class="source-line-no">206</span><span id="line-206">        // see if the resolved, direct dependency contain this name.</span>
<span class="source-line-no">207</span><span id="line-207">        // If not, the dependency is declared in a scope that is not used (it was filtered out by the scope filter</span>
<span class="source-line-no">208</span><span id="line-208">        // when the map was created.</span>
<span class="source-line-no">209</span><span id="line-209">        if (rootDependencyMap.getDirectDependencies().containsKey(dependencyName)) {</span>
<span class="source-line-no">210</span><span id="line-210">            // a direct dependency</span>
<span class="source-line-no">211</span><span id="line-211">            final DependencyNode projectDependencyNode = rootDependencyMap.getDirectDependencies().get(dependencyName);</span>
<span class="source-line-no">212</span><span id="line-212">            assert projectDependencyNode != null;</span>
<span class="source-line-no">213</span><span id="line-213"></span>
<span class="source-line-no">214</span><span id="line-214">            checkState(visibleScopes.accept(projectDependencyNode, ImmutableList.of()),</span>
<span class="source-line-no">215</span><span id="line-215">                    "Dependency %s maps to %s, but scope filter would exclude it. This should never happen!", dependency, projectDependencyNode);</span>
<span class="source-line-no">216</span><span id="line-216">            computeVersionResolutionForDirectDependency(collector, dependency, projectDependencyNode);</span>
<span class="source-line-no">217</span><span id="line-217">        }</span>
<span class="source-line-no">218</span><span id="line-218"></span>
<span class="source-line-no">219</span><span id="line-219">        // could be a dependency in the full dependency list</span>
<span class="source-line-no">220</span><span id="line-220">        final DependencyNode projectDependencyNode = rootDependencyMap.getAllDependencies().get(dependencyName);</span>
<span class="source-line-no">221</span><span id="line-221">        // A project dependency could be e.g. in test scope, but the map has been computed in a narrower scope (e.g. compile)</span>
<span class="source-line-no">222</span><span id="line-222">        // in that case, it does not contain a dependency node for the dependency. That is ok, simply ignore it.</span>
<span class="source-line-no">223</span><span id="line-223">        if (projectDependencyNode == null) {</span>
<span class="source-line-no">224</span><span id="line-224">            return;</span>
<span class="source-line-no">225</span><span id="line-225">        }</span>
<span class="source-line-no">226</span><span id="line-226">        checkState(visibleScopes.accept(projectDependencyNode, ImmutableList.of()),</span>
<span class="source-line-no">227</span><span id="line-227">                "Dependency %s maps to %s, but scope filter would exclude it. This should never happen!", dependency, projectDependencyNode);</span>
<span class="source-line-no">228</span><span id="line-228"></span>
<span class="source-line-no">229</span><span id="line-229">        try {</span>
<span class="source-line-no">230</span><span id="line-230">            // remove the test scope for resolving all the transitive dependencies. Anything that was pulled in in test scope,</span>
<span class="source-line-no">231</span><span id="line-231">            // now needs its dependencies resolved in compile+runtime scope, not test scope.</span>
<span class="source-line-no">232</span><span id="line-232">            final ScopeLimitingFilter dependencyScope = ScopeLimitingFilter.computeTransitiveScope(dependency.getScope());</span>
<span class="source-line-no">233</span><span id="line-233">            computeVersionResolutionForTransitiveDependencies(collector, dependency, projectDependencyNode, dependencyScope);</span>
<span class="source-line-no">234</span><span id="line-234">        } catch (ProjectBuildingException e) {</span>
<span class="source-line-no">235</span><span id="line-235">            // This is an optimization and a bug workaround at the same time. Some artifacts exist that</span>
<span class="source-line-no">236</span><span id="line-236">            // specify a packaging that is not natively supported by maven (e.g. bundle of OSGi bundles), however they</span>
<span class="source-line-no">237</span><span id="line-237">            // do not bring the necessary extensions to deal with that type. As a result, this causes a "could not read model"</span>
<span class="source-line-no">238</span><span id="line-238">            // exception. Ignore the transitive dependencies if the project node does not suggest any child artifacts.</span>
<span class="source-line-no">239</span><span id="line-239">            if (projectDependencyNode.getChildren().isEmpty()) {</span>
<span class="source-line-no">240</span><span id="line-240">                LOG.debug("Ignoring model building exception for %s, no children were declared", dependency);</span>
<span class="source-line-no">241</span><span id="line-241">            } else {</span>
<span class="source-line-no">242</span><span id="line-242">                LOG.warn("Could not read POM for %s, ignoring project and its dependencies!", dependency);</span>
<span class="source-line-no">243</span><span id="line-243">            }</span>
<span class="source-line-no">244</span><span id="line-244">        }</span>
<span class="source-line-no">245</span><span id="line-245">    }</span>
<span class="source-line-no">246</span><span id="line-246"></span>
<span class="source-line-no">247</span><span id="line-247">    /**</span>
<span class="source-line-no">248</span><span id="line-248">     * Create a version resolution for the given direct requestingDependency and artifact.</span>
<span class="source-line-no">249</span><span id="line-249">     */</span>
<span class="source-line-no">250</span><span id="line-250">    private void computeVersionResolutionForDirectDependency(</span>
<span class="source-line-no">251</span><span id="line-251">            final ImmutableSetMultimap.Builder&lt;QualifiedName, VersionResolution&gt; collector,</span>
<span class="source-line-no">252</span><span id="line-252">            final Dependency requestingDependency,</span>
<span class="source-line-no">253</span><span id="line-253">            final DependencyNode resolvedDependencyNode)</span>
<span class="source-line-no">254</span><span id="line-254">            throws AbstractArtifactResolutionException, VersionRangeResolutionException, MojoExecutionException {</span>
<span class="source-line-no">255</span><span id="line-255">        final QualifiedName requestingDependencyName = QualifiedName.fromDependency(requestingDependency);</span>
<span class="source-line-no">256</span><span id="line-256"></span>
<span class="source-line-no">257</span><span id="line-257">        final RepositorySystem repoSystem = context.getRepositorySystem();</span>
<span class="source-line-no">258</span><span id="line-258"></span>
<span class="source-line-no">259</span><span id="line-259">        Artifact artifact = convertToPomArtifact(requestingDependency.getArtifact());</span>
<span class="source-line-no">260</span><span id="line-260">        if (artifact.isSnapshot()) {</span>
<span class="source-line-no">261</span><span id="line-261">            // convert version of a snapshot artifact to be SNAPSHOT, otherwise the</span>
<span class="source-line-no">262</span><span id="line-262">            // version range resolver will try to match the timestamp version</span>
<span class="source-line-no">263</span><span id="line-263">            artifact = artifact.setVersion(artifact.getBaseVersion());</span>
<span class="source-line-no">264</span><span id="line-264">        }</span>
<span class="source-line-no">265</span><span id="line-265"></span>
<span class="source-line-no">266</span><span id="line-266">        final VersionRangeRequest request = context.createVersionRangeRequest(artifact);</span>
<span class="source-line-no">267</span><span id="line-267">        final VersionRangeResult result = repoSystem.resolveVersionRange(context.getRepositorySystemSession(), request);</span>
<span class="source-line-no">268</span><span id="line-268"></span>
<span class="source-line-no">269</span><span id="line-269">        if (!result.getVersions().contains(resolvedDependencyNode.getVersion())) {</span>
<span class="source-line-no">270</span><span id="line-270">            throw new MojoExecutionException(</span>
<span class="source-line-no">271</span><span id="line-271">                    format("Cannot determine the recommended version of dependency '%s'; its version specification is '%s', and the resolved version is '%s'.",</span>
<span class="source-line-no">272</span><span id="line-272">                            requestingDependency, requestingDependency.getArtifact().getBaseVersion(), resolvedDependencyNode.getVersion()));</span>
<span class="source-line-no">273</span><span id="line-273">        }</span>
<span class="source-line-no">274</span><span id="line-274"></span>
<span class="source-line-no">275</span><span id="line-275">        // dependency range contains the project version (or matches it)</span>
<span class="source-line-no">276</span><span id="line-276"></span>
<span class="source-line-no">277</span><span id="line-277">        // version from the dependency artifact</span>
<span class="source-line-no">278</span><span id="line-278">        final ComparableVersion expectedVersion = getVersion(resolvedDependencyNode);</span>
<span class="source-line-no">279</span><span id="line-279"></span>
<span class="source-line-no">280</span><span id="line-280">        // this is a direct dependency; it made it through the filter in resolveProjectDependency.</span>
<span class="source-line-no">281</span><span id="line-281">        final boolean managedDependency = (resolvedDependencyNode.getManagedBits() &amp; DependencyNode.MANAGED_VERSION) != 0;</span>
<span class="source-line-no">282</span><span id="line-282">        final VersionResolution resolution = VersionResolution.forDirectDependency(QualifiedName.fromProject(context.getRootProject()), expectedVersion,</span>
<span class="source-line-no">283</span><span id="line-283">                managedDependency);</span>
<span class="source-line-no">284</span><span id="line-284"></span>
<span class="source-line-no">285</span><span id="line-285">        if (isIncluded(resolvedDependencyNode, expectedVersion, expectedVersion)) {</span>
<span class="source-line-no">286</span><span id="line-286">            final Strategy strategy = context.getStrategyCache().forQualifiedName(requestingDependencyName);</span>
<span class="source-line-no">287</span><span id="line-287">            checkState(strategy != null, "Strategy for %s is null, this should never happen (could not find default strategy?", requestingDependencyName);</span>
<span class="source-line-no">288</span><span id="line-288"></span>
<span class="source-line-no">289</span><span id="line-289">            if (!strategy.isCompatible(expectedVersion, expectedVersion)) {</span>
<span class="source-line-no">290</span><span id="line-290">                resolution.conflict();</span>
<span class="source-line-no">291</span><span id="line-291">            }</span>
<span class="source-line-no">292</span><span id="line-292">        } else {</span>
<span class="source-line-no">293</span><span id="line-293">            LOG.debug("VersionResolution %s is excluded by configuration.", resolution);</span>
<span class="source-line-no">294</span><span id="line-294">        }</span>
<span class="source-line-no">295</span><span id="line-295"></span>
<span class="source-line-no">296</span><span id="line-296">        try {</span>
<span class="source-line-no">297</span><span id="line-297">            collectorLock.lock();</span>
<span class="source-line-no">298</span><span id="line-298">            collector.put(requestingDependencyName, resolution);</span>
<span class="source-line-no">299</span><span id="line-299">        } finally {</span>
<span class="source-line-no">300</span><span id="line-300">            collectorLock.unlock();</span>
<span class="source-line-no">301</span><span id="line-301">        }</span>
<span class="source-line-no">302</span><span id="line-302">    }</span>
<span class="source-line-no">303</span><span id="line-303"></span>
<span class="source-line-no">304</span><span id="line-304">    /**</span>
<span class="source-line-no">305</span><span id="line-305">     * Resolve all transitive dependencies relative to a given dependency, based off the artifact given. A scope filter can be added which limits the results to</span>
<span class="source-line-no">306</span><span id="line-306">     * the scopes present in that filter.</span>
<span class="source-line-no">307</span><span id="line-307">     */</span>
<span class="source-line-no">308</span><span id="line-308">    private void computeVersionResolutionForTransitiveDependencies(</span>
<span class="source-line-no">309</span><span id="line-309">            final ImmutableSetMultimap.Builder&lt;QualifiedName, VersionResolution&gt; collector,</span>
<span class="source-line-no">310</span><span id="line-310">            final Dependency requestingDependency,</span>
<span class="source-line-no">311</span><span id="line-311">            final DependencyNode dependencyNodeForDependency,</span>
<span class="source-line-no">312</span><span id="line-312">            final DependencyFilter scopeFilter)</span>
<span class="source-line-no">313</span><span id="line-313">            throws AbstractArtifactResolutionException, ProjectBuildingException, DependencyResolutionException {</span>
<span class="source-line-no">314</span><span id="line-314">        final AndDependencyFilter filter = new AndDependencyFilter(scopeFilter, new CheckExclusionsFilter(requestingDependency.getExclusions()));</span>
<span class="source-line-no">315</span><span id="line-315"></span>
<span class="source-line-no">316</span><span id="line-316">        final DependencyMap dependencyMap = new DependencyMapBuilder(context).mapDependency(dependencyNodeForDependency, filter);</span>
<span class="source-line-no">317</span><span id="line-317">        final Collection&lt;DependencyNode&gt; transitiveDependencies = dependencyMap.getAllDependencies().values();</span>
<span class="source-line-no">318</span><span id="line-318">        final QualifiedName requestingDependencyName = QualifiedName.fromDependency(requestingDependency);</span>
<span class="source-line-no">319</span><span id="line-319"></span>
<span class="source-line-no">320</span><span id="line-320">        final ImmutableSet&lt;DependencyNode&gt; filteredDependencies = transitiveDependencies.stream()</span>
<span class="source-line-no">321</span><span id="line-321">                .filter(d -&gt; scopeFilter.accept(d, ImmutableList.of()))</span>
<span class="source-line-no">322</span><span id="line-322">                .filter(d -&gt; !d.getDependency().isOptional())</span>
<span class="source-line-no">323</span><span id="line-323">                .collect(toImmutableSet());</span>
<span class="source-line-no">324</span><span id="line-324"></span>
<span class="source-line-no">325</span><span id="line-325">        for (final DependencyNode dependencyNode : filteredDependencies) {</span>
<span class="source-line-no">326</span><span id="line-326">            final QualifiedName dependencyName = QualifiedName.fromDependencyNode(dependencyNode);</span>
<span class="source-line-no">327</span><span id="line-327"></span>
<span class="source-line-no">328</span><span id="line-328">            final DependencyNode projectDependencyNode = rootDependencyMap.getAllDependencies().get(dependencyName);</span>
<span class="source-line-no">329</span><span id="line-329">            if (projectDependencyNode == null) {</span>
<span class="source-line-no">330</span><span id="line-330">                // the next condition can happen if a dependency is required by one dependency but then overridden by another. e.g.</span>
<span class="source-line-no">331</span><span id="line-331">                //</span>
<span class="source-line-no">332</span><span id="line-332">                //   guava (*29.1-jre*, 25.1-android)</span>
<span class="source-line-no">333</span><span id="line-333">                //    guava 25.1-android depends on org.checkerframework:checker-compat-qual</span>
<span class="source-line-no">334</span><span id="line-334">                //    guava 29.1-jre depends on org.checkerframework:checker-qual</span>
<span class="source-line-no">335</span><span id="line-335">                //</span>
<span class="source-line-no">336</span><span id="line-336">                // as the dependency resolver chose 29.1-jre, only the "checker-qual" dependency will show on the final classpath</span>
<span class="source-line-no">337</span><span id="line-337">                // however, when resolving all dependencies, the code will resolve the dependency which pulls in guava-25.1-android.</span>
<span class="source-line-no">338</span><span id="line-338">                // For that dependency, there will be "checker-compat-qual" in the list of dependencies, but when the code tries to</span>
<span class="source-line-no">339</span><span id="line-339">                // resolve the actual classpath dependency, the "checker-compat-qual" dependency is not in the final classpath.</span>
<span class="source-line-no">340</span><span id="line-340">                //</span>
<span class="source-line-no">341</span><span id="line-341">                // This is normal situation and the dependency can just be dropped.</span>
<span class="source-line-no">342</span><span id="line-342">                //</span>
<span class="source-line-no">343</span><span id="line-343">                continue;</span>
<span class="source-line-no">344</span><span id="line-344">            }</span>
<span class="source-line-no">345</span><span id="line-345"></span>
<span class="source-line-no">346</span><span id="line-346">            final ComparableVersion resolvedVersion = getVersion(projectDependencyNode);</span>
<span class="source-line-no">347</span><span id="line-347">            final ComparableVersion expectedVersion = getVersion(dependencyNode);</span>
<span class="source-line-no">348</span><span id="line-348"></span>
<span class="source-line-no">349</span><span id="line-349">            final boolean managedDependency = (projectDependencyNode.getManagedBits() &amp; DependencyNode.MANAGED_VERSION) != 0;</span>
<span class="source-line-no">350</span><span id="line-350">            final VersionResolution resolution = VersionResolution.forTransitiveDependency(requestingDependencyName, expectedVersion, managedDependency);</span>
<span class="source-line-no">351</span><span id="line-351"></span>
<span class="source-line-no">352</span><span id="line-352">            if (isIncluded(dependencyNode, expectedVersion, resolvedVersion)) {</span>
<span class="source-line-no">353</span><span id="line-353">                final Strategy strategy = context.getStrategyCache().forQualifiedName(dependencyName);</span>
<span class="source-line-no">354</span><span id="line-354">                checkState(strategy != null, "Strategy for %s is null, this should never happen (could not find default strategy?", dependencyName);</span>
<span class="source-line-no">355</span><span id="line-355"></span>
<span class="source-line-no">356</span><span id="line-356">                if (!strategy.isCompatible(expectedVersion, resolvedVersion)) {</span>
<span class="source-line-no">357</span><span id="line-357">                    resolution.conflict();</span>
<span class="source-line-no">358</span><span id="line-358">                }</span>
<span class="source-line-no">359</span><span id="line-359">            }</span>
<span class="source-line-no">360</span><span id="line-360"></span>
<span class="source-line-no">361</span><span id="line-361">            try {</span>
<span class="source-line-no">362</span><span id="line-362">                collectorLock.lock();</span>
<span class="source-line-no">363</span><span id="line-363">                collector.put(dependencyName, resolution);</span>
<span class="source-line-no">364</span><span id="line-364">            } finally {</span>
<span class="source-line-no">365</span><span id="line-365">                collectorLock.unlock();</span>
<span class="source-line-no">366</span><span id="line-366">            }</span>
<span class="source-line-no">367</span><span id="line-367">        }</span>
<span class="source-line-no">368</span><span id="line-368">    }</span>
<span class="source-line-no">369</span><span id="line-369"></span>
<span class="source-line-no">370</span><span id="line-370">    /**</span>
<span class="source-line-no">371</span><span id="line-371">     * Returns true if a given artifact and version should be checked.</span>
<span class="source-line-no">372</span><span id="line-372">     */</span>
<span class="source-line-no">373</span><span id="line-373">    private boolean isIncluded(DependencyNode dependencyNodeForDependency, ComparableVersion expectedVersion, ComparableVersion resolvedVersion) {</span>
<span class="source-line-no">374</span><span id="line-374">        return context.getExclusions().stream().noneMatch(exclusion -&gt; exclusion.matches(dependencyNodeForDependency, expectedVersion, resolvedVersion));</span>
<span class="source-line-no">375</span><span id="line-375">    }</span>
<span class="source-line-no">376</span><span id="line-376"></span>
<span class="source-line-no">377</span><span id="line-377">    /**</span>
<span class="source-line-no">378</span><span id="line-378">     * Return a version object for an Artifact.</span>
<span class="source-line-no">379</span><span id="line-379">     */</span>
<span class="source-line-no">380</span><span id="line-380">    private static ComparableVersion getVersion(DependencyNode dependencyNode)</span>
<span class="source-line-no">381</span><span id="line-381">            throws OverConstrainedVersionException {</span>
<span class="source-line-no">382</span><span id="line-382">        checkNotNull(dependencyNode, "dependencyNode is null");</span>
<span class="source-line-no">383</span><span id="line-383"></span>
<span class="source-line-no">384</span><span id="line-384">        checkState(dependencyNode.getVersion() != null, "DependencyNode %s has a null version selected. Please report a bug!", dependencyNode);</span>
<span class="source-line-no">385</span><span id="line-385">        return new ComparableVersion(dependencyNode.getVersion().toString());</span>
<span class="source-line-no">386</span><span id="line-386">    }</span>
<span class="source-line-no">387</span><span id="line-387">}</span>




























































</pre>
</div>
</main>
</body>
</html>